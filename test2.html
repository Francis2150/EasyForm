<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Signature Polisher — Upload, Vectorize, Smooth & Export</title>
<style>
  body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial; margin:18px; color:#111 }
  h1 { font-size:20px; margin:0 0 8px 0 }
  #top { display:flex; gap:12px; flex-wrap:wrap; align-items:center }
  #controls { display:flex; gap:8px; align-items:center; margin-top:8px; flex-wrap:wrap }
  .panel { border:1px solid #e0e0e0; padding:12px; border-radius:8px; background:#fff; box-shadow:0 1px 2px rgba(0,0,0,0.03) }
  #canvasWrap { width:760px; max-width:100%; height:420px; border-radius:6px; overflow:hidden; background:#f7f7f7; position:relative }
  canvas { width:100%; height:100%; display:block }
  #sel { position:absolute; border:2px dashed rgba(0,0,0,0.5); pointer-events:none; display:none }
  label { font-size:13px }
  input[type=range] { width:160px }
  button { padding:8px 12px; border-radius:6px; border:1px solid #bbb; background:white; cursor:pointer }
  button.primary { background:#0b75f5; color:white; border-color:#0b75f5 }
  .danger { color:#a33; font-weight:600 }
  footer { margin-top:12px; font-size:13px; color:#555 }
</style>
</head>
<body>
  <h1>Signature Polisher</h1>
  <div id="top">
    <div class="panel">
      <div><input id="file" type="file" accept="image/*"></div>
      <div style="margin-top:8px">
        <button id="auto">Auto-detect</button>
        <button id="vectorize" class="primary">Vectorize & Smooth</button>
        <button id="downloadSvg">Download SVG</button>
        <button id="downloadPng">Download PNG</button>
      </div>
      <div id="controls" style="margin-top:8px">
        <label>Threshold <input id="th" type="range" min="0" max="255" value="130"></label>
        <label>Smoothing <input id="smooth" type="range" min="0" max="6" value="3"></label>
        <label>Pen width <input id="penw" type="range" min="1" max="60" value="18"></label>
      </div>
      <div style="margin-top:8px; font-size:13px; color:#444">
        Upload your own signature image, select or auto-detect the area, then vectorize and smooth. Do not use to forge others.
      </div>
    </div>
    <div class="panel" style="flex:1; min-width:260px">
      <div><strong>Preview Options</strong></div>
      <div style="margin-top:8px">
        <label><input id="showRaster" type="checkbox" checked> show extracted raster mask</label>
      </div>
      <div style="margin-top:8px; font-size:13px; color:#444">
        The tool produces an editable SVG path that you can download and use as a polished vector signature.
      </div>
    </div>
  </div>

  <div style="margin-top:12px" class="panel">
    <div id="canvasWrap">
      <canvas id="cv" width="1200" height="800"></canvas>
      <div id="sel"></div>
      <!-- SVG overlay -->
      <div id="svgOverlay" style="position:absolute; left:0; top:0; width:100%; height:100%; pointer-events:none"></div>
    </div>
  </div>

<script>
/* Signature Polisher
 - Uses client-side image processing
 - Extracts alpha via threshold
 - Contours via marching squares / border tracing
 - Smooths path (Chaikin subdivision)
 - Renders SVG path with stroke (variable width from slider)
 - Exports SVG or raster PNG
 Note: For performance, large selections are downscaled.
*/

const fileEl = document.getElementById('file');
const cv = document.getElementById('cv');
const ctx = cv.getContext('2d');
const selDiv = document.getElementById('sel');
const svgOverlay = document.getElementById('svgOverlay');
const autoBtn = document.getElementById('auto');
const vectorizeBtn = document.getElementById('vectorize');
const downloadSvgBtn = document.getElementById('downloadSvg');
const downloadPngBtn = document.getElementById('downloadPng');
const thSlider = document.getElementById('th');
const smoothSlider = document.getElementById('smooth');
const penwSlider = document.getElementById('penw');
const showRaster = document.getElementById('showRaster');

let img = new Image();
let imgLoaded=false;
let imgBox = null; // {x,y,w,h} in canvas coords
let sel = null; // user selection in canvas coords

// draw placeholder
function clearCanvas() {
  ctx.fillStyle = '#f7f7f7';
  ctx.fillRect(0,0,cv.width, cv.height);
}
clearCanvas();

// fit image into canvas while preserving aspect
function drawImageFit() {
  clearCanvas();
  if (!imgLoaded) return;
  const cw = cv.clientWidth, ch = cv.clientHeight;
  // canvas actual drawing size is canvas.width/height; we will draw to that resolution
  const viewW = cv.width, viewH = cv.height;
  // compute fit
  const r = img.width / img.height;
  let drawW = viewW, drawH = Math.round(viewW / r);
  if (drawH > viewH) { drawH = viewH; drawW = Math.round(viewH * r); }
  const dx = Math.round((viewW - drawW)/2);
  const dy = Math.round((viewH - drawH)/2);
  ctx.drawImage(img, dx, dy, drawW, drawH);
  imgBox = { x: dx, y: dy, w: drawW, h: drawH };
  // reset selection overlay
  sel = null;
  selDiv.style.display = 'none';
  svgOverlay.innerHTML = '';
}

// file load
fileEl.addEventListener('change', (e)=>{
  const f = e.target.files && e.target.files[0];
  if (!f) return;
  const url = URL.createObjectURL(f);
  img = new Image();
  img.onload = () => {
    imgLoaded = true;
    // scale canvas pixel size to a good working resolution (limit)
    const maxW = 1600, maxH = 1200;
    const scale = Math.min(1, Math.min(maxW / img.width, maxH / img.height));
    cv.width = Math.round(img.width * scale);
    cv.height = Math.round(img.height * scale);
    // ensure canvas displayed size matches reasonable viewport; we keep CSS size via parent
    drawImageFit();
    URL.revokeObjectURL(url);
  };
  img.src = url;
});

// dragging selection
let dragging=false, startPt=null;
cv.addEventListener('mousedown', e=>{
  if (!imgLoaded) return;
  const rect = cv.getBoundingClientRect();
  const x = (e.clientX - rect.left) * (cv.width / rect.width);
  const y = (e.clientY - rect.top) * (cv.height / rect.height);
  dragging=true; startPt={x,y};
  sel = {x,y,w:0,h:0};
  updateSelDiv();
});
window.addEventListener('mousemove', e=>{
  if (!dragging || !startPt) return;
  const rect = cv.getBoundingClientRect();
  const x = (e.clientX - rect.left) * (cv.width / rect.width);
  const y = (e.clientY - rect.top) * (cv.height / rect.height);
  sel.x = Math.min(startPt.x, x);
  sel.y = Math.min(startPt.y, y);
  sel.w = Math.abs(x - startPt.x);
  sel.h = Math.abs(y - startPt.y);
  updateSelDiv();
});
window.addEventListener('mouseup', ()=>{
  if (!dragging) return;
  dragging=false; startPt=null;
  if (sel && (sel.w < 6 || sel.h < 6)) { sel = null; selDiv.style.display='none'; }
});

function updateSelDiv(){
  if (!sel) { selDiv.style.display='none'; return; }
  const rect = cv.getBoundingClientRect();
  // convert canvas coords to client coords
  const left = sel.x * (rect.width / cv.width);
  const top = sel.y * (rect.height / cv.height);
  const w = sel.w * (rect.width / cv.width);
  const h = sel.h * (rect.height / cv.height);
  selDiv.style.left = left + 'px';
  selDiv.style.top = top + 'px';
  selDiv.style.width = w + 'px';
  selDiv.style.height = h + 'px';
  selDiv.style.display = 'block';
}

// Auto-detect dark bounding box (simple approach)
autoBtn.addEventListener('click', ()=>{
  if (!imgLoaded) return alert('Load an image first');
  // sample small downscale to speed up
  const sampleW = 300;
  const sampleH = Math.round(sampleW * (img.height / img.width));
  const tmp = document.createElement('canvas'); tmp.width = sampleW; tmp.height = sampleH;
  const tctx = tmp.getContext('2d');
  tctx.drawImage(img, 0,0, sampleW, sampleH);
  const d = tctx.getImageData(0,0,tmp.width,tmp.height).data;
  const lum = (i)=> 0.2126*d[i]+0.7152*d[i+1]+0.0722*d[i+2];
  const thr = parseInt(thSlider.value,10);
  let minX=sampleW, minY=sampleH, maxX=0, maxY=0, found=false;
  for (let y=0;y<sampleH;y++){
    for (let x=0;x<sampleW;x++){
      const i = (y*sampleW+x)*4;
      if (lum(i) < thr) { found=true; minX=Math.min(minX,x); minY=Math.min(minY,y); maxX=Math.max(maxX,x); maxY=Math.max(maxY,y); }
    }
  }
  if (!found) return alert('Auto-detect found nothing—try lowering threshold');
  // map back to canvas coordinates
  const drawW = imgBox.w, drawH = imgBox.h;
  const bx = imgBox.x + Math.round((minX / sampleW) * drawW);
  const by = imgBox.y + Math.round((minY / sampleH) * drawH);
  const bw = Math.round(((maxX-minX)/sampleW) * drawW);
  const bh = Math.round(((maxY-minY)/sampleH) * drawH);
  sel = { x: bx, y: by, w: bw, h: bh };
  updateSelDiv();
});

// Helper: extract alpha mask from selected region (returns small canvas)
function extractMaskCanvas(selection){
  // selection in canvas pixels (cv.width/cv.height)
  const rect = selection || { x: imgBox.x, y: imgBox.y, w: imgBox.w, h: imgBox.h };
  // clamp
  const sx = Math.max(0, Math.floor(rect.x));
  const sy = Math.max(0, Math.floor(rect.y));
  const sw = Math.max(1, Math.min(cv.width - sx, Math.floor(rect.w)));
  const sh = Math.max(1, Math.min(cv.height - sy, Math.floor(rect.h)));
  // downscale if huge for performance
  const maxDim = 1200;
  const down = Math.max(1, Math.max(sw / maxDim, sh / maxDim));
  const outW = Math.max(2, Math.floor(sw / down));
  const outH = Math.max(2, Math.floor(sh / down));
  const tmp = document.createElement('canvas'); tmp.width = outW; tmp.height = outH;
  const tctx = tmp.getContext('2d');
  // draw portion of cv (we draw image from original scaled fit)
  tctx.drawImage(cv, sx, sy, sw, sh, 0,0, outW, outH);
  // threshold to alpha mask
  const im = tctx.getImageData(0,0,outW,outH);
  const d = im.data; const thr = parseInt(thSlider.value,10);
  for (let i=0;i<d.length;i+=4){
    const L = 0.2126*d[i] + 0.7152*d[i+1] + 0.0722*d[i+2];
    if (L < thr) {
      // ink -> black opaque
      d[i]=0; d[i+1]=0; d[i+2]=0; d[i+3]=255;
    } else {
      // transparent
      d[i+3]=0;
    }
  }
  tctx.putImageData(im,0,0);
  return tmp;
}

// SHOW raster mask preview if requested
function showRasterMask(maskCanvas){
  const rect = cv.getBoundingClientRect();
  // remove old preview if any
  if (showRaster.checked) {
    // draw mask overlay onto the main canvas area (we'll redraw image then overlay)
    drawImageFit();
    // draw mask centered at selection
    const sx = sel ? sel.x : imgBox.x;
    const sy = sel ? sel.y : imgBox.y;
    const sw = sel ? sel.w : imgBox.w;
    const sh = sel ? sel.h : imgBox.h;
    ctx.save();
    ctx.globalCompositeOperation = 'source-over';
    ctx.globalAlpha = 0.85;
    ctx.drawImage(maskCanvas, 0,0, maskCanvas.width, maskCanvas.height, sx, sy, sw, sh);
    ctx.restore();
  } else {
    drawImageFit();
  }
}

// Simple marching squares contour tracing to produce polygon(s) from alpha mask
function contoursFromMask(maskCanvas){
  const w = maskCanvas.width, h = maskCanvas.height;
  const tctx = maskCanvas.getContext('2d');
  const im = tctx.getImageData(0,0,w,h).data;
  // build binary grid: 1 = ink pixel (alpha>0)
  const grid = new Uint8Array(w*h);
  for (let i=0;i<w*h;i++) grid[i] = im[i*4 + 3] > 0 ? 1 : 0;

  // We'll use a simple border-follow algorithm to extract outer contours.
  const visited = new Uint8Array(w*h);
  const contours = [];

  function idx(x,y){ return y*w + x; }
  function inBounds(x,y){ return x>=0 && y>=0 && x<w && y<h; }

  // 8-neighbor border tracing (simple)
  for (let y=0;y<h;y++){
    for (let x=0;x<w;x++){
      if (grid[idx(x,y)] && !visited[idx(x,y)]) {
        // begin flood fill to mark component and collect boundary points
        // do a stack-based flood to mark component
        const stack = [[x,y]];
        const comp = [];
        visited[idx(x,y)] = 1;
        while (stack.length){
          const [cx,cy] = stack.pop();
          comp.push([cx,cy]);
          for (let oy=-1; oy<=1; oy++){
            for (let ox=-1; ox<=1; ox++){
              const nx = cx+ox, ny = cy+oy;
              if (inBounds(nx,ny) && !visited[idx(nx,ny)] && grid[idx(nx,ny)]) {
                visited[idx(nx,ny)] = 1;
                stack.push([nx,ny]);
              }
            }
          }
        }
        // now we have component pixels; find its boundary pixels (those with at least one 4-neighbor empty)
        const boundary = [];
        const set = new Set(comp.map(p=>p[0]+','+p[1]));
        for (const p of comp){
          const [px,py] = p;
          let isBoundary=false;
          const neigh = [[1,0],[-1,0],[0,1],[0,-1]];
          for (const n of neigh){
            const nx = px+n[0], ny = py+n[1];
            if (!inBounds(nx,ny) || !grid[idx(nx,ny)]) { isBoundary=true; break; }
          }
          if (isBoundary) boundary.push([px,py]);
        }
        // Sort boundary into an ordered path using nearest neighbor heuristic (not perfect, but workable)
        if (boundary.length){
          // start from left-most-top-most
          boundary.sort((a,b)=> a[0]-b[0] || a[1]-b[1]);
          const path = [];
          const used = new Set();
          let cur = boundary[0];
          path.push(cur);
          used.add(cur[0]+','+cur[1]);
          for (let k=1;k<boundary.length;k++){
            // find nearest unused
            let best=null, bestd=1e9, bi=-1;
            for (let i=0;i<boundary.length;i++){
              const key = boundary[i][0]+','+boundary[i][1];
              if (used.has(key)) continue;
              const dx = boundary[i][0]-cur[0], dy = boundary[i][1]-cur[1];
              const d = dx*dx + dy*dy;
              if (d < bestd){ bestd=d; best=boundary[i]; bi=i; }
            }
            if (!best) break;
            path.push(best);
            used.add(best[0]+','+best[1]);
            cur = best;
          }
          // convert points to float coordinates centered on pixels (we'll scale later)
          // Optionally compress by skipping near-colinear points
          contours.push(path.map(p=>[p[0]+0.5, p[1]+0.5]));
        }
      }
    }
  }
  return contours; // array of paths (each is array of [x,y] in mask coordinates)
}

// Chaikin subdivision smoothing (k iterations)
function chaikinSmooth(points, iterations){
  if (!points || points.length < 3) return points;
  let pts = points.slice();
  for (let it=0; it<iterations; it++){
    const out = [];
    for (let i=0;i<pts.length-1;i++){
      const p0 = pts[i], p1 = pts[i+1];
      const q = [0.75*p0[0] + 0.25*p1[0], 0.75*p0[1] + 0.25*p1[1]];
      const r = [0.25*p0[0] + 0.75*p1[0], 0.25*p0[1] + 0.75*p1[1]];
      out.push(q); out.push(r);
    }
    // optional: close by connecting last to first
    // For signatures, we treat open paths — but if it's closed we could handle accordingly.
    pts = out;
  }
  return pts;
}

// Build SVG path string from points
function pathFromPoints(points, scale){
  if (!points || points.length===0) return '';
  const s = [];
  for (let i=0;i<points.length;i++){
    const p = points[i];
    const x = (p[0]*scale).toFixed(2), y = (p[1]*scale).toFixed(2);
    if (i===0) s.push('M '+x+' '+y);
    else s.push('L '+x+' '+y);
  }
  return s.join(' ');
}

// Vectorize & render
vectorizeBtn.addEventListener('click', async ()=>{
  if (!imgLoaded) return alert('Load an image first');
  // get mask canvas for selection
  const mask = extractMaskCanvas(sel);
  // show raster preview if toggled
  showRasterMask(mask);
  // get contours
  const contours = contoursFromMask(mask);
  if (!contours || contours.length===0) return alert('No ink detected — try lowering threshold or selecting a larger area');
  // smooth each contour
  const smoothIters = parseInt(smoothSlider.value,10);
  const smoothed = contours.map(c => chaikinSmooth(c, smoothIters));
  // Build an SVG where mask coords map to the selected region size (sx->w, sy->h)
  // Determine scale to map mask pixels back to canvas selection size
  const maskW = mask.width, maskH = mask.height;
  const targetW = sel ? sel.w : imgBox.w;
  const targetH = sel ? sel.h : imgBox.h;
  const sx = sel ? sel.x : imgBox.x;
  const sy = sel ? sel.y : imgBox.y;
  const scaleX = targetW / maskW;
  const scaleY = targetH / maskH;
  const scale = Math.min(scaleX, scaleY);
  // Build SVG markup
  const penWidth = parseInt(penwSlider.value,10);
  // create SVG element
  const svgNS = 'http://www.w3.org/2000/svg';
  const svgEl = document.createElementNS(svgNS,'svg');
  svgEl.setAttribute('width', targetW);
  svgEl.setAttribute('height', targetH);
  svgEl.setAttribute('viewBox', `0 0 ${targetW} ${targetH}`);
  svgEl.style.width = '100%';
  svgEl.style.height = '100%';
  // make defs for subtle texture using feTurbulence + feComposite to emulate slight paper/ink
  const defs = document.createElementNS(svgNS,'defs');
  defs.innerHTML = `
    <filter id="inkTexture" x="-20%" y="-20%" width="140%" height="140%">
      <feTurbulence baseFrequency="0.8" numOctaves="1" stitchTiles="stitch" result="t"/>
      <feColorMatrix type="saturate" values="0" result="mono"/>
      <feComponentTransfer>
        <feFuncA type="table" tableValues="0 0 1"/>
      </feComponentTransfer>
      <feBlend in="SourceGraphic" in2="mono" mode="multiply"/>
    </filter>
  `;
  svgEl.appendChild(defs);

  // add group to position paths
  const g = document.createElementNS(svgNS,'g');
  g.setAttribute('transform', `translate(0,0)`);
  svgEl.appendChild(g);

  // create path(s)
  for (let i=0;i<smoothed.length;i++){
    const pts = smoothed[i];
    if (!pts || pts.length<2) continue;
    const d = pathFromPoints(pts, scale);
    const path = document.createElementNS(svgNS,'path');
    path.setAttribute('d', d);
    path.setAttribute('fill','none');
    path.setAttribute('stroke','#000');
    path.setAttribute('stroke-linecap','round');
    path.setAttribute('stroke-linejoin','round');
    path.setAttribute('stroke-width', String(penWidth));
    path.setAttribute('filter','url(#inkTexture)');
    g.appendChild(path);
  }

  // place the SVG overlay at the selected position within the canvasWrap
  svgOverlay.innerHTML = '';
  // create container wrapper to position properly using same client coords
  // We'll embed the svg markup in an <svg> element inside overlay, positioned via CSS transform
  svgOverlay.appendChild(svgEl);
  // position using CSS of svgOverlay (svgOverlay covers whole canvas; we need to shift the viewBox visually)
  // To position the SVG to match selection area: we will wrap in a div with transform
  // Instead, set svgEl style: absolute positioning via viewBox already sets width/height
  // We'll position by setting marginLeft/top via client coords mapping
  // But easier: create a containing element with absolute positioning corresponding to selection client rect
  const parent = svgOverlay;
  // remove previous positioned children and create absolutely positioned wrapper
  parent.innerHTML = '';
  const wrap = document.createElement('div');
  wrap.style.position='absolute';
  wrap.style.left = (sx * (svgOverlay.clientWidth / cv.width)) + 'px';
  wrap.style.top = (sy * (svgOverlay.clientHeight / cv.height)) + 'px';
  wrap.style.width = (targetW * (svgOverlay.clientWidth / cv.width)) + 'px';
  wrap.style.height = (targetH * (svgOverlay.clientHeight / cv.height)) + 'px';
  wrap.appendChild(svgEl);
  parent.appendChild(wrap);

  // Save generated SVG markup for download
  vectorizeBtn._svgString = (new XMLSerializer()).serializeToString(svgEl);

  alert('Vectorization complete — preview shown. Use Download SVG or Download PNG.');
});

// Download SVG
downloadSvgBtn.addEventListener('click', ()=>{
  const s = vectorizeBtn._svgString;
  if (!s) return alert('No SVG generated yet. Click "Vectorize & Smooth" first.');
  const blob = new Blob([s], { type: 'image/svg+xml;charset=utf-8' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href = url; a.download = 'signature_polished.svg'; document.body.appendChild(a); a.click(); a.remove();
  URL.revokeObjectURL(url);
});

// Download PNG (rasterize SVG at high resolution)
downloadPngBtn.addEventListener('click', async ()=>{
  const s = vectorizeBtn._svgString;
  if (!s) return alert('No SVG generated yet. Click "Vectorize & Smooth" first.');
  const penW = parseInt(penwSlider.value,10);
  // create an offscreen svg with white background and viewBox size
  // We need to rasterize at e.g. 2x for quality
  const scaleFactor = 3;
  // create image
  const svgBlob = new Blob([s], { type: 'image/svg+xml;charset=utf-8' });
  const url = URL.createObjectURL(svgBlob);
  const imgRaster = new Image();
  imgRaster.onload = () => {
    const w = imgRaster.width * scaleFactor;
    const h = imgRaster.height * scaleFactor;
    const off = document.createElement('canvas'); off.width = Math.max(1,w); off.height = Math.max(1,h);
    const octx = off.getContext('2d');
    // transparent background
    octx.clearRect(0,0,off.width,off.height);
    // draw svg scaled
    octx.drawImage(imgRaster, 0,0, off.width, off.height);
    off.toBlob((blob) => {
      const u = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href=u; a.download='signature_polished.png'; document.body.appendChild(a); a.click(); a.remove();
      URL.revokeObjectURL(u);
      URL.revokeObjectURL(url);
    }, 'image/png');
  };
  imgRaster.onerror = (e) => { URL.revokeObjectURL(url); alert('Failed to rasterize SVG in this browser'); };
  imgRaster.src = url;
});

// toggle show raster checkbox redraw
showRaster.addEventListener('change', ()=> {
  if (!imgLoaded) return;
  // redraw either original or mask overlay
  if (vectorizeBtn._lastMaskCanvas) showRasterMask(vectorizeBtn._lastMaskCanvas);
  else drawImageFit();
});

// initial sizing: scale canvas CSS to hold area
(function setCanvasCss(){
  const wrap = document.getElementById('canvasWrap');
  const rect = wrap.getBoundingClientRect();
  // ensure cv CSS width/height to fill container (we rely on absolute internal pixel dimensions)
  cv.style.width = '100%';
  cv.style.height = '100%';
})();
</script>

<footer>
  <span class="danger">Important:</span> this tool is intended to polish signatures you own. I will not assist in forging or impersonation. By using this, you confirm you have the right to edit the uploaded signature.
</footer>
</body>
</html>
