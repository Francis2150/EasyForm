<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Signature Extractor & Pen-Style Renderer (Safe Use)</title>
<style>
  body { font-family: system-ui, Arial; margin: 18px; color:#111 }
  h1 { font-size: 20px; margin-bottom: 4px }
  .row { display:flex; gap:12px; align-items:flex-start; flex-wrap:wrap }
  #uploader { margin-bottom:8px }
  #canvasWrap { position: relative; border:1px solid #ddd; width:680px; max-width:100%; height:420px; background:#f7f7f7; }
  canvas#sourceCanvas { width:100%; height:100%; display:block; }
  /* selection rectangle */
  .sel { position:absolute; border:2px dashed rgba(0,0,0,0.6); background: rgba(255,255,255,0.02); pointer-events:none; }
  #controls { margin-top:12px; display:flex; gap:8px; flex-wrap:wrap; }
  input[type=range] { width:160px }
  button { padding:8px 12px; border-radius:6px; border:1px solid #bbb; background:white; cursor:pointer }
  button.primary { background:#0b75f5; color:white; border-color:#0b75f5 }
  .hint { margin-top:10px; font-size:13px; color:#444; max-width:680px }
  footer { margin-top:14px; font-size:13px; color:#666 }
  .danger { color:#a33; font-weight:600 }
</style>
</head>
<body>
  <h1>Signature Extractor & Pen-Style Renderer</h1>
  <div class="row">
    <div>
      <input id="fileInput" type="file" accept="image/*" />
      <div class="hint">
        Upload an image you own. Drag to select the signature area on the canvas. Use the sliders to tune threshold and texture. Download creates a transparent PNG.
      </div>
      <div class="hint danger">
        Do not use this tool to alter official ID cards or to forge signatures on legal documents. Use only for legitimate, non-fraudulent purposes.
      </div>
      <div id="controls">
        <label>Threshold <input id="thresh" type="range" min="0" max="255" value="120" /></label>
        <label>Smooth <input id="smooth" type="range" min="0" max="10" value="1" /></label>
        <label>Texture <input id="grain" type="range" min="0" max="100" value="18" /></label>
        <button id="autoCrop">Auto-detect darker area</button>
        <button id="extract" class="primary">Extract & Render</button>
        <button id="download">Download PNG</button>
      </div>
    </div>
  </div>

  <div id="canvasWrap">
    <canvas id="sourceCanvas" width="1280" height="800"></canvas>
    <div id="sel" class="sel" style="display:none"></div>
  </div>

  <div class="hint">
    Tip: If auto-detect doesn't pick the signature correctly, drag on the image to select the area manually. Use Threshold to tune what counts as "ink".
  </div>

<script>
/*
Client-side Signature Extractor
- Upload image
- Manual drag-to-select crop rectangle
- Simple thresholding to separate ink from background
- Optional smoothing and grain to resemble pen texture
- Download transparent PNG

Ethics: Do not use to forge official documents.
*/

const fileInput = document.getElementById('fileInput');
const canvas = document.getElementById('sourceCanvas');
const ctx = canvas.getContext('2d', { willReadFrequently: true });
const selDiv = document.getElementById('sel');
const threshSlider = document.getElementById('thresh');
const smoothSlider = document.getElementById('smooth');
const grainSlider = document.getElementById('grain');
const autoBtn = document.getElementById('autoCrop');
const extractBtn = document.getElementById('extract');
const downloadBtn = document.getElementById('download');

let img = new Image();
let scale = 1;
let imgX=0, imgY=0, imgW=0, imgH=0;
let dragging=false, selStart=null, selRect=null;

// helper to fit image into canvas
function drawImageToCanvas() {
  const cw = canvas.clientWidth;
  const ch = canvas.clientHeight;
  // actual canvas pixel size -> keep high resolution
  const DPR = window.devicePixelRatio || 1;
  canvas.width = Math.round(canvas.clientWidth * DPR);
  canvas.height = Math.round(canvas.clientHeight * DPR);
  ctx.setTransform(DPR,0,0,DPR,0,0);
  ctx.clearRect(0,0,canvas.clientWidth, canvas.clientHeight);
  if(!img.src) {
    ctx.fillStyle = '#f7f7f7';
    ctx.fillRect(0,0,canvas.clientWidth, canvas.clientHeight);
    return;
  }
  // fit with aspect
  const cwVis = canvas.clientWidth;
  const chVis = canvas.clientHeight;
  const rImg = img.width / img.height;
  if (cwVis / chVis > rImg) {
    // container wider -> limit by height
    imgH = chVis;
    imgW = imgH * rImg;
  } else {
    imgW = cwVis;
    imgH = imgW / rImg;
  }
  imgX = (cwVis - imgW)/2;
  imgY = (chVis - imgH)/2;
  scale = imgW / img.width;
  ctx.drawImage(img, imgX, imgY, imgW, imgH);
}

// load file
fileInput.addEventListener('change', (e) => {
  const f = e.target.files && e.target.files[0];
  if (!f) return;
  const url = URL.createObjectURL(f);
  img = new Image();
  img.onload = () => {
    drawImageToCanvas();
    selDiv.style.display = 'none';
    selRect = null;
    URL.revokeObjectURL(url);
  };
  img.src = url;
});

// redraw on resize
window.addEventListener('resize', () => { drawImageToCanvas(); if (selRect) drawSelectionDiv(); });

// selection via mouse (desktop)
canvas.addEventListener('mousedown', (ev) => {
  if (!img.src) return;
  dragging = true;
  const rect = canvas.getBoundingClientRect();
  const x = ev.clientX - rect.left;
  const y = ev.clientY - rect.top;
  selStart = {x, y};
  selRect = {x, y, w:0, h:0};
  drawSelectionDiv();
});
window.addEventListener('mousemove', (ev) => {
  if (!dragging || !selStart) return;
  const rect = canvas.getBoundingClientRect();
  const x = ev.clientX - rect.left;
  const y = ev.clientY - rect.top;
  selRect.x = Math.min(selStart.x, x);
  selRect.y = Math.min(selStart.y, y);
  selRect.w = Math.abs(x - selStart.x);
  selRect.h = Math.abs(y - selStart.y);
  drawSelectionDiv();
});
window.addEventListener('mouseup', () => {
  if (dragging) {
    dragging = false;
    selStart = null;
    if (selRect && (selRect.w < 6 || selRect.h < 6)) {
      // small click - treat as none
      selRect = null;
      selDiv.style.display = 'none';
    }
  }
});

function drawSelectionDiv() {
  if (!selRect) { selDiv.style.display = 'none'; return; }
  selDiv.style.display = 'block';
  selDiv.style.left = (selRect.x) + 'px';
  selDiv.style.top = (selRect.y) + 'px';
  selDiv.style.width = (selRect.w) + 'px';
  selDiv.style.height = (selRect.h) + 'px';
}

// convert selection rectangle in canvas-view coordinates to original image pixels
function selToImageRect() {
  if (!selRect) return null;
  // canvas client dims
  const cw = canvas.clientWidth, ch = canvas.clientHeight;
  // intersection with image area
  const x1 = Math.max(selRect.x, imgX), y1 = Math.max(selRect.y, imgY);
  const x2 = Math.min(selRect.x + selRect.w, imgX + imgW), y2 = Math.min(selRect.y + selRect.h, imgY + imgH);
  if (x2 <= x1 || y2 <= y1) return null;
  // convert to image pixels
  const relX = (x1 - imgX) / scale;
  const relY = (y1 - imgY) / scale;
  const relW = (x2 - x1) / scale;
  const relH = (y2 - y1) / scale;
  // clamp
  return {
    x: Math.max(0, Math.floor(relX)),
    y: Math.max(0, Math.floor(relY)),
    w: Math.max(1, Math.min(Math.floor(relW), img.width - Math.floor(relX))),
    h: Math.max(1, Math.min(Math.floor(relH), img.height - Math.floor(relY)))
  };
}

// Auto-detect darker bounding box (simple)
autoBtn.addEventListener('click', () => {
  if (!img.src) return;
  // downscale sample for speed
  const S = 256;
  const tmp = document.createElement('canvas');
  tmp.width = S; tmp.height = Math.round(S * img.height / img.width);
  const tctx = tmp.getContext('2d');
  tctx.drawImage(img, 0, 0, tmp.width, tmp.height);
  const d = tctx.getImageData(0,0,tmp.width,tmp.height);
  const vals = new Uint8Array(tmp.width*tmp.height);
  for (let i=0;i<d.data.length;i+=4){
    const r=d.data[i], g=d.data[i+1], b=d.data[i+2];
    // luminance
    vals[i/4] = 0.2126*r + 0.7152*g + 0.0722*b;
  }
  // find bounding box of darker pixels under a threshold
  const thr = 160;
  let minX=tmp.width, minY=tmp.height, maxX=0, maxY=0, found=false;
  for (let y=0;y<tmp.height;y++){
    for (let x=0;x<tmp.width;x++){
      const v = vals[y*tmp.width + x];
      if (v < thr) { found=true; minX=Math.min(minX,x); minY=Math.min(minY,y); maxX=Math.max(maxX,x); maxY=Math.max(maxY,y); }
    }
  }
  if (!found) {
    alert('Auto-detect found nothing dark enough. Try lowering threshold slider.');
    return;
  }
  // map back to canvas coords
  const box = {
    x: Math.floor((minX / tmp.width) * imgW) + imgX,
    y: Math.floor((minY / tmp.height) * imgH) + imgY,
    w: Math.ceil(((maxX-minX) / tmp.width) * imgW),
    h: Math.ceil(((maxY-minY) / tmp.height) * imgH)
  };
  selRect = box;
  drawSelectionDiv();
});

// Main extraction pipeline
extractBtn.addEventListener('click', () => {
  if (!img.src) { alert('Upload an image first.'); return; }
  // if no selection, use entire image area
  let imageRect = selToImageRect();
  if (!imageRect) {
    // default to entire image
    imageRect = { x: 0, y: 0, w: img.width, h: img.height };
  }
  // create an offscreen canvas at the selected image native resolution (cap to avoid huge)
  const maxDim = 1600; // keep reasonable
  const scaleDown = Math.max(1, Math.max(imageRect.w / maxDim, imageRect.h / maxDim));
  const w = Math.max(1, Math.floor(imageRect.w / scaleDown));
  const h = Math.max(1, Math.floor(imageRect.h / scaleDown));
  const off = document.createElement('canvas');
  off.width = w; off.height = h;
  const octx = off.getContext('2d');
  // draw selected area scaled into offscreen
  octx.drawImage(img, imageRect.x, imageRect.y, imageRect.w, imageRect.h, 0,0,w,h);
  let id = octx.getImageData(0,0,w,h);
  const data = id.data;
  const threshold = parseInt(threshSlider.value,10); // 0..255; lower => keep lighter pixels? we treat as luminance below threshold = ink
  // Convert to grayscale + thresholding to generate alpha mask
  for (let i=0;i<data.length;i+=4){
    const r=data[i], g=data[i+1], b=data[i+2];
    // compute luminance (0 dark, 255 bright)
    const L = 0.2126*r + 0.7152*g + 0.0722*b;
    // decide ink pixels
    // we treat pixels darker than threshold as ink
    if (L < threshold) {
      // keep darker as black-ish, amplify contrast a bit
      // produce near-black color but preserve some texture
      const factor = 1.0 + ( (threshold - L) / 255 ) * 0.6;
      const val = Math.max(10, Math.min(255, 30 * factor));
      data[i] = data[i+1] = data[i+2] = 0; // black ink
      data[i+3] = 255; // opaque
    } else {
      // transparent
      data[i+3] = 0;
    }
  }
  // apply a small morphological smoothing if requested
  const smooth = parseInt(smoothSlider.value,10);
  if (smooth > 0) {
    const tmpCanvas = document.createElement('canvas');
    tmpCanvas.width = w; tmpCanvas.height = h;
    const tctx = tmpCanvas.getContext('2d');
    tctx.putImageData(id,0,0);
    // draw blurred scaled copies to soften edges
    tctx.globalCompositeOperation = 'source-in';
    for (let i=0;i<smooth;i++){
      tctx.filter = `blur(${0.6 + i*0.6}px)`;
      // draw itself onto itself slightly offset to thicken strokes
      tctx.drawImage(tmpCanvas, -0.3, -0.3);
    }
    tctx.filter = 'none';
    id = tctx.getImageData(0,0,w,h);
  }

  // create final canvas for rendering with texture
  const final = document.createElement('canvas');
  final.width = w; final.height = h;
  const fctx = final.getContext('2d');
  // clear
  fctx.clearRect(0,0,w,h);
  // put extracted alpha image as mask
  fctx.putImageData(id,0,0);

  // Create pen-like texture: generate grain and multiply
  const grain = parseInt(grainSlider.value,10);
  if (grain > 0) {
    const gcan = document.createElement('canvas');
    gcan.width = w; gcan.height = h;
    const gctx = gcan.getContext('2d');
    const gimg = gctx.createImageData(w,h);
    for (let i=0;i<gimg.data.length;i+=4){
      // white background with small gray noise
      const n = 255 - Math.round(Math.random() * grain);
      gimg.data[i] = gimg.data[i+1] = gimg.data[i+2] = n;
      gimg.data[i+3] = 255;
    }
    gctx.putImageData(gimg,0,0);
    // composite the extracted signature over a copy of the grain using multiply to add texture
    // create temp
    const tmp = document.createElement('canvas'); tmp.width=w; tmp.height=h;
    const tctx = tmp.getContext('2d');
    // draw grain
    tctx.drawImage(gcan,0,0);
    // draw signature as source-atop to only keep grain where signature exists
    tctx.globalCompositeOperation = 'destination-in';
    tctx.drawImage(final,0,0);
    // Now draw onto final canvas using multiply to darken signature with grain
    fctx.globalCompositeOperation = 'source-over';
    fctx.drawImage(tmp,0,0);
    // restore op
    fctx.globalCompositeOperation = 'source-over';
  }

  // Slight stroke thinning / expansion to mimic pen pressure by drawing multiple alpha-offsets
  // We'll produce an output canvas with white background transparent
  // To accentuate, we can convert non-transparent pixels to near-black and keep alpha.
  // But since our current canvas already has color as black with alpha, we'll normalize:
  const out = document.createElement('canvas');
  // Optionally scale up for smoother look
  const scaleUp = 1; // you can increase to 2 for higher resolution
  out.width = Math.floor(w * scaleUp);
  out.height = Math.floor(h * scaleUp);
  const outctx = out.getContext('2d');
  // fill transparent
  outctx.clearRect(0,0,out.width,out.height);
  // draw final into out at scale
  outctx.drawImage(final, 0,0, out.width, out.height);

  // create a result preview in main canvas area
  // show on main canvas: center the result and a white background preview behind it
  const previewW = Math.min(canvas.clientWidth - 20, out.width);
  const previewH = Math.round((previewW / out.width) * out.height);
  // clear main canvas
  ctx.clearRect(0,0,canvas.clientWidth, canvas.clientHeight);
  // fill light background
  ctx.fillStyle = '#fff';
  ctx.fillRect(0,0,canvas.clientWidth, canvas.clientHeight);
  // draw the extracted signature centered
  const px = (canvas.clientWidth - previewW)/2, py = (canvas.clientHeight - previewH)/2;
  ctx.drawImage(out, 0,0,out.width,out.height, px,py, previewW, previewH);

  // Save the result as a blob in a hidden place for download
  out.toBlob((blob) => {
    // store blob for download by assigning to data attribute
    downloadBtn._blob = blob;
    // show a small overlay selection removed (we keep selection hidden after extraction)
    selDiv.style.display = 'none';
    alert('Extraction complete. Click "Download PNG" to save a transparent signature image.');
  }, 'image/png');

});

// download handler
downloadBtn.addEventListener('click', () => {
  const blob = downloadBtn._blob;
  if (!blob) { alert('No extracted signature available. Click "Extract & Render" first.'); return; }
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'signature_extracted.png';
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
});

// initial draw placeholder
drawImageToCanvas();
</script>
</body>
</html>
